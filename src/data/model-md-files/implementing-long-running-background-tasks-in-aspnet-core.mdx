---
title: "Implementing Long-Running Background Tasks in ASP.NET Core"
description: "Learn how to implement long-running background tasks in ASP.NET Core using hosted services and background workers."
pubDate: "2024-10-26T00:00:00.000Z"
heroImage: "https://imagekit.io/your-account/long_running_background_tasks.jpg"
category: "ASP.NET Core"
tags: ["aspnetcore", "background tasks", "hosted services", "dotnet"]
---

## Implementing Long-Running Background Tasks in ASP.NET Core

**Long-running background tasks are essential for performing operations that are not time-sensitive and can be executed asynchronously without blocking the main application thread.**

In this article, we will explore how to implement long-running background tasks in ASP.NET Core using hosted services and background workers. We will cover the following topics:

1. Why Use Background Tasks?
2. Implementing Background Tasks with IHostedService
3. Using BackgroundService for Simplicity
4. Handling Errors and Graceful Shutdown
5. Real-World Examples

### 1. Why Use Background Tasks?

Background tasks are useful for performing operations such as:

- Sending emails
- Processing data
- Generating reports
- Cleaning up resources
- Running scheduled jobs

By offloading these tasks to background workers, you can improve the responsiveness and performance of your web application.

### 2. Implementing Background Tasks with IHostedService

The `IHostedService` interface provides a way to implement background tasks in ASP.NET Core. It defines two methods: `StartAsync` and `StopAsync`.

```csharp
public class LongRunningService : IHostedService
{
    private readonly ILogger<LongRunningService> _logger;
    private Timer _timer;

    public LongRunningService(ILogger<LongRunningService> logger)
    {
        _logger = logger;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Long Running Service is starting.");
        _timer = new Timer(DoWork, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
        return Task.CompletedTask;
    }

    private void DoWork(object state)
    {
        _logger.LogInformation("Long Running Service is working.");
        // Your long-running task logic here
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Long Running Service is stopping.");
        _timer?.Change(Timeout.Infinite, 0);
        return Task.CompletedTask;
    }
}
```

### 3. Using BackgroundService for Simplicity

The `BackgroundService` class provides a simpler way to implement background tasks by abstracting away some of the boilerplate code:

```csharp
public class SimpleBackgroundService : BackgroundService
{
    private readonly ILogger<SimpleBackgroundService> _logger;

    public SimpleBackgroundService(ILogger<SimpleBackgroundService> logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation("Simple Background Service is working.");
            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
        }
    }
}
```

### 4. Handling Errors and Graceful Shutdown

It's essential to handle errors properly and ensure a graceful shutdown of background tasks:

```csharp
public class RobustBackgroundService : BackgroundService
{
    private readonly ILogger<RobustBackgroundService> _logger;

    public RobustBackgroundService(ILogger<RobustBackgroundService> logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        try
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await DoWorkAsync(stoppingToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error occurred while executing background task");
                    await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "Fatal error in background service");
            throw;
        }
    }

    private async Task DoWorkAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Executing background task");
        await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
    }
}
```

### 5. Real-World Examples

Here's a practical example of a background service that processes emails:

```csharp
public class EmailSenderService : BackgroundService
{
    private readonly ILogger<EmailSenderService> _logger;
    private readonly IEmailSender _emailSender;
    private readonly IEmailQueue _emailQueue;

    public EmailSenderService(
        ILogger<EmailSenderService> logger,
        IEmailSender emailSender,
        IEmailQueue emailQueue)
    {
        _logger = logger;
        _emailSender = emailSender;
        _emailQueue = emailQueue;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var email = await _emailQueue.DequeueAsync(stoppingToken);
            if (email != null)
            {
                try
                {
                    await _emailSender.SendEmailAsync(email, stoppingToken);
                    _logger.LogInformation("Email sent successfully");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to send email");
                    await _emailQueue.RequeueAsync(email);
                }
            }
            await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);
        }
    }
}
```

## Conclusion

Long-running background tasks are an essential part of modern web applications. ASP.NET Core provides robust support for implementing these tasks through `IHostedService` and `BackgroundService`. By following the patterns and practices outlined in this article, you can create reliable and efficient background processing systems in your applications.
